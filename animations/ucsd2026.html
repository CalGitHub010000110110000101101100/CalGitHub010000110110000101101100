<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>UCSD 2026 animated logo</title>
    <meta name="description" content="hhh" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" type="text/css" href="/sheep3.css" />

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"
      charset="utf-8"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"
      charset="utf-8"
    ></script>
    <script
      src="https://sheeptester.github.io/javascripts/easing.js"
      charset="utf-8"
    ></script>
    <script src="/sheep3.js" charset="utf-8"></script>

    <style>
      @import url('https://www.ucsd.edu/_resources/css/vendor/brix_sans.css');
      @import url('https://sheeptester.github.io/sheep-sim/src/css/common.css');
      @import url('https://sheeptester.github.io/sheep-sim/src/css/canvas.css');

      body {
        justify-content: center;
        align-items: center;
        background-image: radial-gradient(circle at 50% 50%, #e2e2e2, #8e8e8e);
      }

      #canvas-wrapper {
        width: 500px;
        height: 500px;
        overflow: hidden;
      }
      #canvas-wrapper.server-icon {
        width: 48px;
        height: 48px;
        border-radius: 10px;
      }
      #canvas-wrapper.circle {
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <div id="canvas-wrapper"></div>
    <button id="download">Download</button>
    <script type="module">
      import { WindowResizeListener } from 'https://sheeptester.github.io/sheep-sim/src/view/window-resize-listener.mjs'
      import { Canvas } from 'https://sheeptester.github.io/sheep-sim/src/view/canvas.mjs'
      import { Animator } from 'https://sheeptester.github.io/sheep-sim/src/view/animator.mjs'
      import { Vector2 } from 'https://sheeptester.github.io/sheep-sim/src/utils/vector2.mjs'
      const { easeInQuart, easeOutQuart, easeOutExpo } = Easing

      class ImitationCanvas {
        constructor ({
          canvas = document.createElement('canvas'),
          size = new Vector2()
        } = {}) {
          this.canvas = canvas
          this.canvas.width = size.x
          this.canvas.height = size.y
          this.context = canvas.getContext('2d')
          canvas.classList.add('canvas')

          this.position = new Vector2()
          this.size = size
        }
      }

      function loadImage (url) {
        return new Promise((resolve, reject) => {
          const image = new Image()
          image.addEventListener('load', () => resolve(image))
          image.addEventListener('error', reject)
          image.src = url
        })
      }

      function download (filename, content) {
        const url = URL.createObjectURL(content)
        const saveLink = Object.assign(document.createElement('a'), {
          href: url,
          download: filename
        })
        document.body.append(saveLink)
        saveLink.click()
        URL.revokeObjectURL(url)
        saveLink.remove()
      }

      const canvas = new Canvas().setWrapper(
        document.getElementById('canvas-wrapper')
      )
      const animator = new Animator()
      const resizeListener = new WindowResizeListener({ resizers: [canvas] })

      const gifOptions = {
        FPS: 60,
        SIZE: 300,
        MP4: false
      }

      class Timings {
        duration = 0
        #events = []
        #eventsMap = {}

        /** Marks an event at the current time. Mutates object, chainable. */
        event (id) {
          const event = { id, time: this.duration }
          this.#events.push(event)
          this.#eventsMap[id] = event
          return this
        }

        /** Adds to the current time. Mutates object, chainable. */
        then (time) {
          this.duration += time
          return this
        }

        component (time, { enter, exit, render }) {
          // May want to add offsets relative to an event later
          const enterTime = this.#eventsMap[enter.at].time
          const exitTime = this.#eventsMap[exit.at].time
          // This math will probably die with certain numbers
          const insideRange =
            enterTime < exitTime
              ? enterTime < time && time < exitTime + exit.for
              : time > enterTime || time < exitTime + exit.for
          if (insideRange) {
            const transitioning =
              enterTime < time && time < enterTime + enter.for
                ? 'in'
                : exitTime < time && time < exitTime + exit.for
                ? 'out'
                : null
            render({
              inTime:
                transitioning === 'in' ? (time - enterTime) / enter.for : 1,
              outTime:
                transitioning === 'out' ? (time - exitTime) / exit.for : 0,
              transitioning
            })
          }
        }
      }

      const timings = new Timings()
        .event('to-ucsd')
        .then(1000)
        .event('to-amogus')
        .then(1000)
        .event('to-2026')
        .then(1000)

      class Animation {
        canvas
        images
        #gradient

        constructor (canvas, images) {
          this.canvas = canvas
          this.images = images
        }

        draw (time) {
          const { canvas, images } = this
          const { context: c } = canvas
          c.fillStyle = 'black'
          c.fillRect(0, 0, ...canvas.size)

          timings.component(time, {
            enter: { at: 'to-2026', for: 800 },
            exit: { at: 'to-amogus', for: 800 },
            render: ({ inTime, outTime, transitioning }) => {
              const y =
                transitioning === 'in'
                  ? (1 - Easing.easeInOutCubic(inTime)) * -3 * canvas.size.y
                  : Easing.easeInOutCubic(outTime) * -3 * canvas.size.y
              const gradient = canvas.context.createLinearGradient(
                0,
                y,
                0,
                y + canvas.size.y
              )
              gradient.addColorStop(0, '#00619A')
              gradient.addColorStop(0.5, '#143356')
              gradient.addColorStop(1, 'black')
              c.fillStyle = gradient
              c.fillRect(0, 0, canvas.size.x, canvas.size.y)
              c.strokeRect(0, 0, canvas.size.x, canvas.size.y)
            }
          })

          c.save()
          c.translate(...canvas.size)
          c.rotate(-Math.PI / 4)
          c.fillStyle = '#FFCD00'
          c.fillRect(-102 / 2, -1157 / 2, 204 / 2, 2314 / 2)
          c.fillRect((-204 * 1.5 - 42) / 2, -1730 / 4, 204 / 2, 1730 / 2)
          c.fillRect((204 / 2 + 42) / 2, -1730 / 4, 204 / 2, 1730 / 2)
          c.restore()

          c.shadowColor = 'black'
          c.shadowBlur = 50
          c.textAlign = 'center'
          c.fillStyle = 'white'
          c.font = '190px "BrixSansBold"'
          c.fillText('2026', canvas.size.x / 2, 342)
          c.font = '66px "BrixSansBold"'
          c.fillText('UC SAN DIEGO', canvas.size.x / 2, 201)
          c.fillText('UC SAN DIEGO', canvas.size.x / 2, 201)
          c.shadowColor = 'transparent'
          c.fillText('UC SAN DIEGO', canvas.size.x / 2, 201)
          c.font = '190px "BrixSansBold"'
          c.fillText('2026', canvas.size.x / 2, 342)
        }
      }

      async function main () {
        const options = { speed: 1, serverIcon: false, circle: false }
        const animation = new Animation(canvas, {
          crewmate: await loadImage(
            'https://cdn.discordapp.com/attachments/986565854105833493/1003045624083665007/OVERWRITE_ME.png'
          )
        })
        function render () {
          const now = Date.now() * options.speed
          const time = now % timings.duration
          animation.draw(time)
        }
        animator.renderers.push({ render })

        await resizeListener.listen().resizeNow()
        animator.start()

        const gui = new dat.GUI()
        gui.add(options, 'speed', 0, 5)
        const gifOptionsFolder = gui.addFolder('GIF options')
        for (const key of Object.keys(gifOptions)) {
          gifOptionsFolder.add(gifOptions, key)
        }
        gui.add(options, 'serverIcon').onChange(() => {
          if (options.serverIcon) {
            canvas.wrapper.classList.add('server-icon')
          } else {
            canvas.wrapper.classList.remove('server-icon')
          }
        })
        gui.add(options, 'circle').onChange(() => {
          if (options.circle) {
            canvas.wrapper.classList.add('circle')
          } else {
            canvas.wrapper.classList.remove('circle')
          }
        })

        const downloadBtn = document.getElementById('download')
        downloadBtn.addEventListener('click', async e => {
          downloadBtn.disabled = true
          const dummyCanvas = new ImitationCanvas({
            size: new Vector2(gifOptions.SIZE, gifOptions.SIZE)
          })
          const animation = new Animation(dummyCanvas, logo)
          const frameDelay = 1000 / gifOptions.FPS
          if (gifOptions.MP4) {
            await import(
              'https://unpkg.com/@ffmpeg/ffmpeg@0.9.5/dist/ffmpeg.min.js'
            )
            const { createFFmpeg, fetchFile } = FFmpeg
            const ffmpeg = createFFmpeg({ log: true })
            await ffmpeg.load()
            let frame = 0
            for (let i = 0; i < timings.duration; i += frameDelay) {
              animation.draw(i)
              const blob = await new Promise(resolve => {
                dummyCanvas.canvas.toBlob(resolve, 'image/png')
              })
              ffmpeg.FS('writeFile', `frame${frame}.png`, await fetchFile(blob))
              frame++
            }
            await ffmpeg.run(
              '-r',
              gifOptions.FPS + '',
              '-i',
              `frame%d.png`,
              'output.mp4'
            )
            const data = ffmpeg.FS('readFile', 'output.mp4')
            download(
              'gunn-discord.mp4',
              new Blob([data.buffer], { type: 'video/mp4' })
            )
            downloadBtn.disabled = false
          } else {
            const gif = new GIF({
              workerScript: './gif-worker.js',
              width: gifOptions.SIZE,
              height: gifOptions.SIZE
            })
            gif.on('finished', blob => {
              download('gunn-discord.gif', blob)
              animator.start()
              downloadBtn.disabled = false
            })
            for (let i = 0; i < timings.duration; i += frameDelay) {
              animation.draw(i)
              gif.addFrame(dummyCanvas.context, {
                delay: frameDelay,
                copy: true
              })
            }
            gif.render()
          }
        })
      }

      main()

      Object.assign(window, {
        canvas,
        animator
      })
    </script>
  </body>
</html>
