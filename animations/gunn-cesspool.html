<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Unofficial Gunn Discord cesspool animated logo</title>
    <meta name="description" content="Uses CANVAS owo" />

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/sheep3.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js" charset="utf-8"></script>
    <script src="https://sheeptester.github.io/javascripts/easing.js" charset="utf-8"></script>
    <script src="/sheep3.js" charset="utf-8"></script>

    <style>
      @import url('https://sheeptester.github.io/sheep-sim/src/css/common.css');
      @import url('https://sheeptester.github.io/sheep-sim/src/css/canvas.css');

      body {
        justify-content: center;
        align-items: center;
        background-image: radial-gradient(circle at 50% 50%, #e2e2e2, #8e8e8e);
      }

      #canvas-wrapper {
        width: 300px;
        height: 300px;
      }
      #canvas-wrapper.server-icon {
        width: 48px;
        height: 48px;
        overflow: hidden;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div id="canvas-wrapper"></div>
    <button id="download">Download</button>
    <script type="module">
      import { WindowResizeListener } from 'https://sheeptester.github.io/sheep-sim/src/view/window-resize-listener.mjs'
      import { Canvas } from 'https://sheeptester.github.io/sheep-sim/src/view/canvas.mjs'
      import { Animator } from 'https://sheeptester.github.io/sheep-sim/src/view/animator.mjs'
      import { Vector2 } from 'https://sheeptester.github.io/sheep-sim/src/utils/vector2.mjs'
      const { easeInQuart, easeOutQuart, easeOutExpo } = Easing

      class ImitationCanvas {
        constructor ({
          canvas = document.createElement('canvas'),
          size = new Vector2()
        } = {}) {
          this.canvas = canvas
          this.canvas.width = size.x
          this.canvas.height = size.y
          this.context = canvas.getContext('2d')
          canvas.classList.add('canvas')

          this.position = new Vector2()
          this.size = size
        }
      }

      function loadImage (url) {
        return new Promise((resolve, reject) => {
          const image = new Image()
          image.addEventListener('load', () => resolve(image))
          image.addEventListener('error', reject)
          image.src = url
        })
      }

      function download (filename, content) {
        const saveLink = document.createElement('a')
        document.body.appendChild(saveLink)

        // Use special ms version if available to get it working on Edge.
        if (navigator.msSaveOrOpenBlob) {
          navigator.msSaveOrOpenBlob(content, filename)
          return
        }

        const url = window.URL.createObjectURL(content)
        saveLink.href = url
        saveLink.download = filename
        saveLink.click()
        window.URL.revokeObjectURL(url)
        document.body.removeChild(saveLink)
      }

      const canvas = new Canvas()
        .setWrapper(document.getElementById('canvas-wrapper'))
      const animator = new Animator()
      const resizeListener = new WindowResizeListener({ resizers: [canvas] })

      const durations = {
        LOGO_HOLD: 500,
        LOGO_OUT: 500,
        BACK_SLIDE_START: 50,
        BACK_SLIDE: 250,
        GUNN_IN: 500,
        GUNN_HOLD: 1000,
        LOGO_IN: 500,
        CIRCLE_OFFSET: -250,
        CIRCLE_SPACING: 150,
        CIRCLE: 750,
        LAST_CIRCLE: 500,
        CHAR_SPACING: 40,
        CHAR: 500
      }
      const timings = {
        LOGO_HOLD: 0,
        LOGO_OUT: durations.LOGO_HOLD,
        BACK_SLIDE: durations.LOGO_HOLD + durations.LOGO_OUT
          + durations.BACK_SLIDE_START,
        BACK_SLIDE_END: durations.LOGO_HOLD + durations.LOGO_OUT
          + durations.BACK_SLIDE_START + durations.BACK_SLIDE,
        GUNN_IN: durations.LOGO_HOLD + durations.LOGO_OUT,
        GUNN_HOLD: durations.LOGO_HOLD + durations.LOGO_OUT + durations.GUNN_IN,
        LOGO_IN: durations.LOGO_HOLD + durations.LOGO_OUT + durations.GUNN_IN
          + durations.GUNN_HOLD,
        CIRCLE_START: durations.LOGO_HOLD + durations.LOGO_OUT + durations.GUNN_IN
          + durations.GUNN_HOLD + durations.CIRCLE_OFFSET,
        CIRCLE_END: durations.LOGO_HOLD + durations.LOGO_OUT + durations.GUNN_IN
          + durations.GUNN_HOLD + durations.CIRCLE_OFFSET + durations.LOGO_IN,
        DURATION: durations.LOGO_HOLD + durations.LOGO_OUT + durations.GUNN_IN
          + durations.GUNN_HOLD + durations.LOGO_IN
      }
      const colours = {
        BACK: '#ff3e3e',
        RED_1: '#ff5454',
        RED_2: '#d03c3c',
        BLACK: '#000000'
      }
      const reds = [colours.RED_2, colours.RED_1, colours.BACK]
      const LOGO_SCALE = 0.8
      const GUNN = 'GUNN'
      const CHAR_SPACING = 1 / 5
      const CHAR_SIZE = 1 / 5
      const CHAR_SKEW = 1
      const FRAME_DELAY = 1000 / 60
      const GIF_SIZE = 300

      function between (value, a, b) {
        return value >= a && value < b
      }

      class Animation {
        constructor (canvas, logo) {
          this.canvas = canvas
          this.logo = logo
        }

        draw (time) {
          const { canvas, logo } = this
          const { context: c } = canvas
          c.clearRect(0, 0, ...canvas.size)
          // Background
          if (between(time, timings.LOGO_HOLD, timings.BACK_SLIDE_END)) {
            c.fillStyle = colours.BACK
            c.fillRect(0, 0, ...canvas.size)
          } else {
            c.fillStyle = colours.BLACK
            c.fillRect(0, 0, ...canvas.size)
          }
          // Black in animation
          if (between(time, timings.BACK_SLIDE, timings.BACK_SLIDE_END)) {
            const prog = (time - timings.BACK_SLIDE) / durations.BACK_SLIDE
            c.fillStyle = colours.BLACK
            c.fillRect((1 - easeOutQuart(prog)) * canvas.size.x, 0, ...canvas.size)
          }
          // Gunn text
          if (time >= timings.GUNN_IN) {
            const spacing = canvas.size.x * CHAR_SPACING
            c.font = `700 ${canvas.size.y * CHAR_SIZE}px "Roboto", sans-serif`
            c.textAlign = 'center'
            c.textBaseline = 'middle'
            c.fillStyle = 'white'
            for (let i = 0; i < GUNN.length; i++) {
              const char = GUNN[i]
              const offsetX = i * spacing
                - (GUNN.length - 1) * spacing / 2
              const delay = i * durations.CHAR_SPACING
              const charTime = time - timings.GUNN_IN - delay
              if (charTime > 0) {
                c.save()
                c.translate(...canvas.size.clone().scale(1 / 2).add({
                  x: offsetX
                }))
                if (charTime < durations.CHAR) {
                  const prog = easeOutQuart(charTime / durations.CHAR)
                  c.translate((1 - prog) * canvas.size.x, 0)
                  // 1  0.5 0
                  // 0  1   0
                  // dx 0   1
                  c.transform(1, 0, (1 - prog) * -CHAR_SKEW, 1, 0, 0, 0, 0)
                }
                c.fillText(char, 0, 0)
                c.restore()
              }
            }
          }
          // Circle animation
          const maxRadius = canvas.size.length / 2
          for (let i = 0; i < reds.length; i++) {
            const red = reds[i]
            const delay = i * durations.CIRCLE_SPACING
            const redTime = time - timings.CIRCLE_START - delay
            const duration = i === reds.length - 1
              ? durations.LAST_CIRCLE
              : durations.CIRCLE
            if (redTime > 0) {
              const radius = redTime < duration
                ? easeOutQuart(redTime / duration)
                  * maxRadius
                : maxRadius
              const centre = canvas.size.clone().scale(1 / 2)
              c.fillStyle = red
              c.beginPath()
              c.moveTo(...centre.clone().add({ x: radius }))
              c.arc(...centre, radius, 0, 2 * Math.PI)
              c.fill()
            }
          }
          // Logo
          if (between(time, timings.LOGO_HOLD, timings.GUNN_IN) || time >= timings.LOGO_IN) {
            const scale = time >= timings.LOGO_IN
              ? easeOutExpo((time - timings.LOGO_IN) / durations.LOGO_IN)
                * LOGO_SCALE
              : LOGO_SCALE
            const logoSize = canvas.size.clone().scale(scale)
            c.save()
            c.translate(...canvas.size.clone().scale(1 / 2))
            if (between(time, timings.LOGO_OUT, timings.GUNN_IN)) {
              const prog = easeInQuart(
                (time - timings.LOGO_OUT) / durations.LOGO_OUT
              )
              c.translate(-prog * canvas.size.x, 0)
              c.rotate(-prog * Math.PI / 6)
            } else if (time >= timings.LOGO_IN) {
              c.rotate((1 - easeOutExpo((time - timings.LOGO_IN) / durations.LOGO_IN)) * Math.PI / 6)
            }
            c.drawImage(logo, ...logoSize.clone().scale(-1 / 2), ...logoSize)
            c.restore()
          }
        }
      }

      async function main () {
        const logo = await loadImage('./gunn.png')

        const animation = new Animation(canvas, logo)
        function render () {
          const now = Date.now()
          const time = now % timings.DURATION
          animation.draw(time)
        }
        animator.renderers.push({ render })

        await resizeListener
          .listen()
          .resizeNow()
        animator.start()

        const downloadBtn = document.getElementById('download')
        downloadBtn.addEventListener('click', async e => {
          animator.stop()
          downloadBtn.disabled = true
          const dummyCanvas = new ImitationCanvas({
            size: new Vector2(GIF_SIZE, GIF_SIZE)
          })
          const animation = new Animation(dummyCanvas, logo)
          const gif = new GIF({
            workerScript: './gif-worker.js',
            width: GIF_SIZE,
            height: GIF_SIZE
          })
          gif.on('finished', blob => {
            download('gunn-discord', blob)
            animator.start()
            downloadBtn.disabled = false
          })
          for (let i = timings.LOGO_OUT; i < timings.DURATION + timings.LOGO_OUT; i += FRAME_DELAY) {
            animation.draw(i % timings.DURATION)
            gif.addFrame(dummyCanvas.context, { delay: FRAME_DELAY, copy: true })
          }
          gif.render()
        })
      }

      main()

      Object.assign(window, {
        canvas,
        animator,
        LOGO_SCALE,
        FRAME_DELAY
      })
    </script>
  </body>
</html>
